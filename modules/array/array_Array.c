/* This file has been automatically generated by builder part of the ferite distribution */
/* file: array_Array.c */
/* namespace: Array */

#include <ferite.h>       /* we need this without a doubt */
#include "array_header.h"  /* this is the module header */

FE_NATIVE_FUNCTION( ferite_array_Array_getName_an )
{
   FeriteUnifiedArray *a = NULL;
   double index = 0.0;
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 2, &a, &index );

   { /* Main function body. */
#line 309 "array.fec"

 long rindex = (long)index;
 FeriteString *str = NULL;
 FeriteVariable *var = NULL;
 
 if( a->size > rindex )
 {
 var = a->array[rindex];
 str = ferite_str_new( script, var->vname, 0, FE_CHARSET_DEFAULT );
 }
 else
 str = ferite_str_new( script, "", 0, FE_CHARSET_DEFAULT );
 FE_RETURN_STR( str, FE_TRUE ); 
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

FE_NATIVE_FUNCTION( ferite_array_Array_size_a )
{
   FeriteUnifiedArray *a = NULL;
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 1, &a );

   { /* Main function body. */
#line 156 "array.fec"

 FE_RETURN_LONG( a->size );
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

FE_NATIVE_FUNCTION( ferite_array_Array_shift_a )
{
   FeriteUnifiedArray *a = NULL;
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 1, &a );

   { /* Main function body. */
#line 252 "array.fec"

 FeriteVariable *var = ferite_uarray_shift( script, a );
 FE_RETURN_VAR( var );
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

FE_NATIVE_FUNCTION( ferite_array_Array_unshift_av )
{
   FeriteUnifiedArray *a = NULL;
   FeriteVariable *var = params[1];
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 2, &a, NULL );

   { /* Main function body. */
#line 236 "array.fec"

 
 ferite_uarray_unshift( script, a, var );
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

FE_NATIVE_FUNCTION( ferite_array_Array___join_as )
{
   FeriteUnifiedArray *a = NULL;
   FeriteString *value = NULL;
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 2, &a, &value );

   { /* Main function body. */
#line 435 "array.fec"

 char *string, *join = "";
 FeriteString *str = NULL;
 FeriteBuffer *buf = ferite_buffer_new(script,0);
 FeriteVariable *var = NULL;
 int i, len;

 for (i=0;i<a->size;i++)
 {

 if( a->array[i] != NULL )
 {
 str = ferite_variable_to_str( script, a->array[i], FE_FALSE );
 if( str != NULL )
 ferite_buffer_printf(script,buf,"%s%.*s", join, str->length, str->data);
 ferite_str_destroy(script, str );
 }
 if(!i)
 join = value->data;
 }
 string = ferite_buffer_get(script,buf, &len);
 ferite_buffer_delete(script,buf);

 var = fe_new_str_static("joined_array", string, len, FE_CHARSET_DEFAULT );
 ffree( string );
 FE_RETURN_VAR( var );
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

FE_NATIVE_FUNCTION( ferite_array_Array_del_av )
{
   FeriteUnifiedArray *a = NULL;
   FeriteVariable *var = params[1];
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 2, &a, NULL );

   { /* Main function body. */
#line 271 "array.fec"

 
 ferite_uarray_del_var( script, a, var );
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

FE_NATIVE_FUNCTION( ferite_array_Array_valueExists_av )
{
   FeriteUnifiedArray *a = NULL;
   FeriteVariable *value = params[1];
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 2, &a, NULL );

   { /* Main function body. */
#line 388 "array.fec"

 int i;

 for (i=0;i<a->size;i++)
 {
 if(F_VAR_TYPE(a->array[i]) == F_VAR_TYPE(value))
 {
 switch(F_VAR_TYPE(value))
 {
 case F_VAR_STR:
 if (ferite_str_cmp(script,VAS(a->array[i]), VAS(value)))
 FE_RETURN_TRUE;
 break;
 case F_VAR_LONG:
 if (VAI(a->array[i]) == VAI(value))
 FE_RETURN_TRUE;
 break;
 case F_VAR_DOUBLE:
 if (VAF(a->array[i]) == VAF(value))
 FE_RETURN_TRUE;
 break;
 case F_VAR_OBJ:
 if (VAO(a->array[i]) == VAO(value))
 FE_RETURN_TRUE;
 break;
 case F_VAR_UARRAY:
 if (ferite_uarray_cmp(script, VAUA(a->array[i]), VAUA(value)))
 FE_RETURN_TRUE;
 break;
 }
 }
 }
 FE_RETURN_FALSE;
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

FE_NATIVE_FUNCTION( ferite_array_Array__print_a )
{
   FeriteUnifiedArray *vars = NULL;
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 1, &vars );

   { /* Main function body. */
#line 333 "array.fec"

 
 FeriteIterator *iter;
 FeriteHashBucket *buk;
 iter = ferite_create_iterator(script);

 while((buk = (FeriteHashBucket*)ferite_hash_walk(script,vars->hash,iter)) != NULL)
 {
 printf("['%s'] = ",buk->id);
 if(((FeriteVariable *)(buk->data))->type == F_VAR_STR)
 {
 printf("'%.*s'\n",(int)FE_STRLEN(((FeriteVariable*)(buk->data))), FE_STR2PTR(((FeriteVariable*)(buk->data))));
 }
 else
 {
 printf("<ferite %s>\n", ferite_variable_id_to_str(script,((FeriteVariable*)(buk->data))->type));
 }
 }
 ffree(iter);
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

FE_NATIVE_FUNCTION( ferite_array_Array_pop_a )
{
   FeriteUnifiedArray *a = NULL;
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 1, &a );

   { /* Main function body. */
#line 221 "array.fec"

 FeriteVariable *var = ferite_uarray_pop( script, a );
 FE_RETURN_VAR( var );
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

FE_NATIVE_FUNCTION( ferite_array_Array_resize_an )
{
   FeriteUnifiedArray *a = NULL;
   double size = 0.0;
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 2, &a, &size );

   { /* Main function body. */
#line 832 "array.fec"
 
 ferite_uarray_set_size( script, a, VAI(params[1]) );
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

FE_NATIVE_FUNCTION( ferite_array_Array_keys_a )
{
   FeriteUnifiedArray *a = NULL;
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 1, &a );

   { /* Main function body. */
#line 175 "array.fec"

 FeriteVariable *array, *var;
 char buf[512];
 FeriteHashBucket *buk;
 FeriteIterator *iter;
 int t = 0;

 array = ferite_create_uarray_variable(script,"Array.keys", a->hash->size, FE_STATIC);
 iter = ferite_create_iterator(script);
 while( (buk = (FeriteHashBucket*)ferite_hash_walk(script, a->hash,iter)) != NULL )
 {
 snprintf(buf,512,"index-%d",t);
 var = fe_new_str( buf, buk->id, 0, FE_CHARSET_DEFAULT );
 ferite_uarray_add( script, VAUA(array), var, NULL, FE_ARRAY_ADD_AT_END );
 t++;
 }
 ffree(iter);
 FE_RETURN_VAR(array);
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

FE_NATIVE_FUNCTION( ferite_array_Array_push_av )
{
   FeriteUnifiedArray *a = NULL;
   FeriteVariable *var = params[1];
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 2, &a, NULL );

   { /* Main function body. */
#line 205 "array.fec"

 
 ferite_uarray_push( script, a, var );
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

FE_NATIVE_FUNCTION( ferite_array_Array_keyExists_as )
{
   FeriteUnifiedArray *a = NULL;
   FeriteString *key = NULL;
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 2, &a, &key );

   { /* Main function body. */
#line 367 "array.fec"

 if( ferite_hash_get( script, a->hash, key->data ) != NULL )
 {
 FE_RETURN_TRUE;
 }
 FE_RETURN_FALSE;
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

FE_NATIVE_FUNCTION( ferite_array_Array_getIndex_as )
{
   FeriteUnifiedArray *a = NULL;
   FeriteString *var = NULL;
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 2, &a, &var );

   { /* Main function body. */
#line 288 "array.fec"

 FeriteVariable *ptr = ferite_hash_get( script, a->hash, var->data );
 if( ptr != NULL )
 {
 FE_RETURN_LONG(ptr->index);
 }
 FE_RETURN_LONG(-1);
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

FE_NATIVE_FUNCTION( ferite_array_Array_sort_an )
{
   FeriteUnifiedArray *a = NULL;
   double direction = 0.0;
   FeriteNamespace *self = FE_CONTAINER_TO_NS;

   ferite_get_parameters( params, 2, &a, &direction );

   { /* Main function body. */
#line 668 "array.fec"

        int i, add_pos;
	FeriteFunction *ff = NULL;
	struct sort_variable *arr;
        FeriteVariable *ret, *dup;

        if(!(ret = ferite_create_uarray_variable(script, "Array::sort",
                                                         a->size, FE_STATIC))) {
            FE_RETURN_VOID;
        }

        if(!(arr = fmalloc(a->size * sizeof(struct sort_variable)))) {
            FE_RETURN_VAR(ret);
        }

        if(a->size == 0) FE_RETURN_VAR(ret);

        for(i = 0; i < a->size; i++) {
            arr[i].var = ferite_uarray_get_index(script, a, i);
            /* This ugliness is because the compare function needs the script
             * pointer, but the standard libc qsort() function doesn't have the
 * ability to pass a context pointer to the compare function. So
 * we end up bundling the context pointer with every item in the
 * array to be sorted. */
 arr[i].script = script;
 arr[i].closure = current_recipient;
 }

 if(a->size > 1) {

 if( current_recipient == NULL )
 { 
 /* Check that the members of the array are all the same type. We
 * also need to handle the special case of one being a double and
 * the other being a long: */
 for(i = 1; i < a->size; i++) {
 if((F_VAR_TYPE(arr[i].var) != F_VAR_TYPE(arr[0].var)) &&
 !(F_VAR_TYPE(arr[i].var) == F_VAR_LONG && F_VAR_TYPE(arr[0].var) ==
 F_VAR_DOUBLE) && !(F_VAR_TYPE(arr[i].var) == F_VAR_DOUBLE &&
 F_VAR_TYPE(arr[0].var) == F_VAR_LONG)) {
 ffree(arr);
 ferite_set_error(script, -1, "Variables in array to be "
 "sorted must all be of the same type");
 FE_RETURN_VAR(ret);
 }
 }

 /* If the members are objects, check that they are all of the same
 * class, and that the class has a suitable comparison function: */
 if(F_VAR_TYPE(arr[0].var) == F_VAR_OBJ) {
 for(i = 1; i < a->size; i++) {
 if(VAO(arr[i].var)->oid != VAO(arr[0].var)->oid) {
 ffree(arr);
 ferite_set_error(script, -1, "Objects in array to be "
 "sorted must all be of the same class");
 FE_RETURN_VAR(ret);
 }
 }
 ff = ferite_class_get_function(script, VAO(arr[0].var)->klass,
 "compare");
 for(; ff; ff = ff->next) {
 if(ff->signature[0] && ff->signature[0]->variable &&
 F_VAR_TYPE(ff->signature[0]->variable) == F_VAR_OBJ &&
 ff->signature[1] && ff->signature[1]->variable &&
 F_VAR_TYPE(ff->signature[1]->variable) == F_VAR_OBJ &&
 !ff->signature[2]) {
 break;
 }
 }
 if(!ff) {
 ffree(arr);
 ferite_set_error(script, -1, "No suitable compare function "
 "found in the class of the objects to be sorted");
 FE_RETURN_VAR(ret);
 }
 }
 }
 /* The actual sort itself. fe_compare_vars() is in util.c */
 qsort(arr, a->size, sizeof(struct sort_variable), fe_compare_vars);
 }

 if((int)direction == 1) add_pos = FE_ARRAY_ADD_AT_START;
 else add_pos = FE_ARRAY_ADD_AT_END;
 for(i = 0; i < a->size; i++) {
 if((dup = ferite_duplicate_variable(script, arr[i].var, NULL))) {
 ferite_uarray_add(script, VAUA(ret), dup, dup->vname, add_pos);
 }
	}

 ffree(arr);
	FE_RETURN_VAR(ret);
 
   }
   FE_RETURN_VOID;
   self = NULL;
}

