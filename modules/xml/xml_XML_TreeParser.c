/* This file has been automatically generated by builder part of the ferite distribution */
/* file:  xml_XML_TreeParser.c */
/* class: TreeParser */

#include <ferite.h>       /* we need this without a doubt */
#include "xml_header.h"  /* this is the module header */

FE_NATIVE_FUNCTION( ferite_xml_XML_TreeParser_keepBlanks_b )
{
   char bool = FE_FALSE;
   FeriteObject *self = FE_CONTAINER_TO_OBJECT;
   FeriteObject *super = FE_CONTAINER_TO_OBJECT;

   ferite_get_parameters( params, 1, &bool );

   { /* Main function body. */
#line 1278 "xml.fec"
 
			XMLDoc *tree = (XMLDoc*)self->odata;
			tree->keepBlanks = bool;	
	    
   }
   FE_RETURN_VOID;
   self = NULL;
   super = NULL;
}

FE_NATIVE_FUNCTION( ferite_xml_XML_TreeParser_parseFile_s )
{
   FeriteString *filename = NULL;
   FeriteObject *self = FE_CONTAINER_TO_OBJECT;
   FeriteObject *super = FE_CONTAINER_TO_OBJECT;

   ferite_get_parameters( params, 1, &filename );

   { /* Main function body. */
#line 1107 "xml.fec"

	        XMLDoc *tree = self->odata;
        
	        if( tree->doc ) { 
	            xmlFreeDoc( tree->doc );
	            tree->doc = NULL;
	        }
	        xmlKeepBlanksDefault(tree->keepBlanks);	
	        xmlSetGenericErrorFunc(script, (xmlGenericErrorFunc)tree_error_handler);
	        tree->doc = xmlParseFile( filename->data );
	        if (tree->doc == NULL ) {
	            ferite_error( script, 1, "Document was not parsed successfully. \n");
	            FE_RETURN_FALSE;
	        }
	        tree->node = xmlDocGetRootElement( tree->doc );
	        FE_RETURN_TRUE;
	    
   }
   FE_RETURN_VOID;
   self = NULL;
   super = NULL;
}

FE_NATIVE_FUNCTION( ferite_xml_XML_TreeParser_getDocumentElement_ )
{
   FeriteObject *self = FE_CONTAINER_TO_OBJECT;
   FeriteObject *super = FE_CONTAINER_TO_OBJECT;

   { /* Main function body. */
#line 1239 "xml.fec"

	    
	        XMLDoc *tree = (XMLDoc *)self->odata;
	        if( tree->doc )
	        {
			    FeriteVariable *obj;
			    xmlNode *root_element = NULL;
	    
			    root_element = xmlDocGetRootElement(tree->doc);
	    
			    obj = create_element_node( script, tree->doc, root_element );
			    FE_RETURN_VAR( obj );       	
	        }
	        FE_RETURN_NULL_OBJECT;
	    
   }
   FE_RETURN_VOID;
   self = NULL;
   super = NULL;
}

FE_NATIVE_FUNCTION( ferite_xml_XML_TreeParser_toString_ )
{
   FeriteObject *self = FE_CONTAINER_TO_OBJECT;
   FeriteObject *super = FE_CONTAINER_TO_OBJECT;

   { /* Main function body. */
#line 1192 "xml.fec"

	        XMLDoc *tree = self->odata;
	        FeriteVariable *v = NULL;
        
	        if( tree->doc )
	        {
	            xmlChar *string = NULL;
	            int len;
            
	            xmlIndentTreeOutput = 1;
	            if( tree->doc ) 
	                xmlDocDumpMemoryEnc( tree->doc, &string, &len, NULL);
            
	            v = fe_new_str_static( "xml", (char *)string, len, FE_CHARSET_DEFAULT );
	            xmlFree( string );
	        }
	        else
	            v = fe_new_str_static( "xml", "", 0, FE_CHARSET_DEFAULT );
        
	        FE_RETURN_VAR( v );
	    
   }
   FE_RETURN_VOID;
   self = NULL;
   super = NULL;
}

FE_NATIVE_FUNCTION( ferite_xml_XML_TreeParser_saveToFile_s )
{
   FeriteString *filename = NULL;
   FeriteObject *self = FE_CONTAINER_TO_OBJECT;
   FeriteObject *super = FE_CONTAINER_TO_OBJECT;

   ferite_get_parameters( params, 1, &filename );

   { /* Main function body. */
#line 1222 "xml.fec"

	        XMLDoc *tree = self->odata;
        
	        if( tree->doc )
	        {
	            if( xmlSaveFormatFile( filename->data, tree->doc, 1 ))
	                FE_RETURN_TRUE;
	        }
	        FE_RETURN_FALSE;
	    
   }
   FE_RETURN_VOID;
   self = NULL;
   super = NULL;
}

FE_NATIVE_FUNCTION( ferite_xml_XML_TreeParser_validation_b )
{
   char bool = FE_FALSE;
   FeriteObject *self = FE_CONTAINER_TO_OBJECT;
   FeriteObject *super = FE_CONTAINER_TO_OBJECT;

   ferite_get_parameters( params, 1, &bool );

   { /* Main function body. */
#line 1264 "xml.fec"

	    
	        if( bool == FE_FALSE )
	            xmlDoValidityCheckingDefaultValue = 0;
	        else
	            xmlDoValidityCheckingDefaultValue = 1;
	    
   }
   FE_RETURN_VOID;
   self = NULL;
   super = NULL;
}

FE_NATIVE_FUNCTION( ferite_xml_XML_TreeParser_destructor_ )
{
   FeriteObject *self = FE_CONTAINER_TO_OBJECT;
   FeriteObject *super = FE_CONTAINER_TO_OBJECT;

   { /* Main function body. */
#line 1084 "xml.fec"

	        XMLDoc *tree = self->odata;
        
	        if( tree && tree->doc ) 
	            xmlFreeDoc( tree->doc );
        
	        if( tree )
	            ffree( tree );
        
	        xmlDoValidityCheckingDefaultValue = 0;
	        xmlPedanticParserDefaultValue = 0;
	        xmlKeepBlanksDefault(1);
        
	        xmlSetGenericErrorFunc(NULL, NULL);
	    
   }
   FE_RETURN_VOID;
   self = NULL;
   super = NULL;
}

FE_NATIVE_FUNCTION( ferite_xml_XML_TreeParser_parseChunk_s )
{
   FeriteString *chunk = NULL;
   FeriteObject *self = FE_CONTAINER_TO_OBJECT;
   FeriteObject *super = FE_CONTAINER_TO_OBJECT;

   ferite_get_parameters( params, 1, &chunk );

   { /* Main function body. */
#line 1132 "xml.fec"

	        XMLDoc *tree = self->odata;
        
	        if( tree->doc ) { 
	            xmlFreeDoc( tree->doc );
	            tree->doc = NULL;
	        }
	        xmlKeepBlanksDefault(tree->keepBlanks);	
	        xmlSetGenericErrorFunc(script, (xmlGenericErrorFunc)tree_error_handler);
	        tree->doc = xmlParseMemory( chunk->data, chunk->length );
	        if (tree->doc == NULL ) {
	            ferite_error( script, 1, "Chunk was not parsed successfully. \n");
	            FE_RETURN_FALSE;
	        }
	        tree->node = xmlDocGetRootElement( tree->doc );
	        FE_RETURN_TRUE;
	    
   }
   FE_RETURN_VOID;
   self = NULL;
   super = NULL;
}

FE_NATIVE_FUNCTION( ferite_xml_XML_TreeParser_constructor_ )
{
   FeriteObject *self = FE_CONTAINER_TO_OBJECT;
   FeriteObject *super = FE_CONTAINER_TO_OBJECT;

   { /* Main function body. */
#line 1068 "xml.fec"

			XMLDoc *tree = fcalloc( 1, sizeof( XMLDoc ) );

			tree->doc = NULL;
			tree->node = NULL;
			tree->keepBlanks = 1;
	        self->odata = tree;
        
	        /* set default parser behavior */
	        xmlSubstituteEntitiesDefault(1);
	        xmlDoValidityCheckingDefaultValue = 0;
	        xmlPedanticParserDefaultValue = 0;
	        xmlKeepBlanksDefault(tree->keepBlanks);	
	    
   }
   FE_RETURN_VOID;
   self = NULL;
   super = NULL;
}

FE_NATIVE_FUNCTION( ferite_xml_XML_TreeParser_xpathArray_s )
{
   FeriteString *expr = NULL;
   FeriteObject *self = FE_CONTAINER_TO_OBJECT;
   FeriteObject *super = FE_CONTAINER_TO_OBJECT;

   ferite_get_parameters( params, 1, &expr );

   { /* Main function body. */
#line 1158 "xml.fec"

	        FeriteVariable *v = NULL;
	        XMLDoc *tree = self->odata;
        
	        if( tree->doc ) 
	            v = ParseXPath( script, tree , (const char *) expr->data);
	        else 
	            v = fe_new_array_static( "xpathArray", 0 );
        
	        FE_RETURN_VAR( v );
	    
   }
   FE_RETURN_VOID;
   self = NULL;
   super = NULL;
}

